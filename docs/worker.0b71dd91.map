{"version":3,"sources":["particle/vector-n.ts","particle/neighbors.ts","particle/particle-msg.ts","simulation/behavior/orbits.ts","simulation/behavior/behavior.ts","simulation/bounding/centerScaling.ts","simulation/bounding/bounding.ts","simulation/Simulation.ts","simulation/worker.ts"],"names":[],"mappings":"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","file":"worker.0b71dd91.map","sourceRoot":"../src","sourcesContent":["import { coinFlip, shuffle } from '../util'\n\nexport type Vector = Float32Array\n\ntype VectorMath = (a: Vector, b: Vector | number) => Vector\ntype NumberMath = (a: number, b: number) => number\nconst curryMath = (math: NumberMath): VectorMath => (a, b) => {\n  const c: Vector = new Float32Array(a.length)\n  const isNumB = typeof b === 'number'\n  for (let i = 0, l = a.length; i < l; i++) {\n    const an = a[i]\n    const bn = isNumB ? (b as number) : (b as Vector)[i]\n    c[i] = math(an, bn)\n  }\n  return c\n}\n\nexport const add: VectorMath = curryMath((a, b) => a + b)\nexport const subtract: VectorMath = curryMath((a, b) => a - b)\nexport const multiply: VectorMath = curryMath((a, b) => a * b)\nexport const divide: VectorMath = curryMath((a, b) => a / b)\n\nexport const getDistanceSq = (a: Vector, b: Vector): number => {\n  const delta = subtract(a, b)\n  return getMagnitudeSq(delta)\n}\n\nexport const getDistance = (a: Vector, b: Vector): number =>\n  Math.sqrt(getDistanceSq(a, b))\n\nexport const getMagnitudeSq = (v: Vector): number => {\n  let magnitudeSq = 0\n  for (let i = 0, l = v.length; i < l; i++) {\n    magnitudeSq += v[i] * v[i]\n  }\n  return magnitudeSq\n}\n\nexport const getMagnitude = (v: Vector): number => Math.sqrt(getMagnitudeSq(v))\n\nexport const setMagnitude = (v: Vector, magnitude: number): Vector => {\n  const prevMagnitude = getMagnitude(v)\n  return prevMagnitude === 0\n    ? add(v, Math.sqrt(magnitude / v.length))\n    : multiply(v, magnitude / prevMagnitude)\n}\n\nexport const limitMagnitude = (v: Vector, limit: number): Vector => {\n  const limitSq = limit * limit\n  const currSq = getMagnitudeSq(v)\n  return currSq > limitSq ? multiply(v, limitSq / currSq) : v\n}\n\nexport const getAverage = (vectors: Vector[]): Vector => {\n  if (vectors.length === 0) throw new Error('Cannot average zero vectors')\n  const count = vectors.length\n  const dimensions = vectors[0].length\n  const average: Vector = new Float32Array(dimensions)\n  for (let i = 0; i < count; i++) {\n    for (let j = 0; j < dimensions; j++) {\n      average[j] = average[j] + vectors[i][j] / count\n    }\n  }\n  return average\n}\n\nexport const radialRandomVector = (\n  length: number,\n  radius: number = 1,\n): Vector => {\n  // Algorithm via Colin Ballast\n  const result = new Float32Array(length)\n  let radiusSq = radius * radius\n  for (let i = 0; i < length; i++) {\n    const value = Math.random() * Math.sqrt(radiusSq)\n    const valueSq = value * value\n    radiusSq -= valueSq\n    result[i] = coinFlip() ? value : -value\n  }\n  shuffle(result)\n  return result\n}\n\nexport const assign = (dst: Vector, src: Vector): Vector => {\n  const v: Vector = new Float32Array(dst.length)\n  for (let i = 0, l = dst.length; i < l; i++) {\n    v[i] = i < src.length ? src[i] : dst[i]\n  }\n  return v\n}\n","import { each, map } from '../util'\nimport { Particle } from './particle'\nimport { getMagnitude, subtract, Vector } from './vector-n'\n\n/**\n * A relation from one Particle to another\n */\nexport interface Neighbor {\n  index: number\n  distance: number\n  delta: Vector\n}\n\n/**\n * Each Particle's Neighbor list, by self-same index\n */\nexport type Neighborhood = Neighbor[][]\n\n/**\n * Calculate the Neighbor[] list for each Particle\n */\nexport const getNeighborhood = (particles: Particle[]): Neighborhood =>\n  map(particles, particle => {\n    const neighbors: Neighbor[] = []\n\n    // Find relation with every other Particle\n    each(particles, (other, index) => {\n      if (particle === other) return\n      const delta = subtract(particle.position, other.position)\n      const distance = getMagnitude(delta)\n      return { index, delta, distance }\n    })\n\n    // Sort relations by nearest -> furthest\n    neighbors.sort((a, b) => a.distance - b.distance)\n\n    return neighbors\n  })\n","import { Particle } from './particle'\nimport { Vector } from './vector-n'\n\n/**\n * TypedArrays are converted to objects by JSON stringification\n * ex: [0.5, 0.5, 0.5] -> { 0: 0.5, 1: 0.5, 2: 0.5 }\n */\nexport interface VectorMsg {\n  [index: number]: number\n}\n\nexport interface ParticleMsg {\n  dimensions: number\n  position: VectorMsg\n  velocity: VectorMsg\n  acceleration: VectorMsg\n}\n\nexport const toParticle = ({\n  dimensions,\n  position,\n  velocity,\n  acceleration,\n}: ParticleMsg): Particle => ({\n  dimensions,\n  position: toVector(position),\n  velocity: toVector(velocity),\n  acceleration: toVector(acceleration),\n})\n\nconst toVector = (msg: VectorMsg): Vector => {\n  let i = 0\n  const list = []\n  while (msg[i] !== undefined) {\n    list[i] = msg[i]\n    i++\n  }\n  return new Float32Array(list)\n}\n","import {\n  add,\n  divide,\n  getMagnitudeSq,\n  multiply,\n  setMagnitude,\n} from '../../particle/vector-n'\nimport { clamp, each } from '../../util'\nimport { Behavior, BehaviorNames } from './behavior'\n\nexport interface OrbitsSpec {\n  name: BehaviorNames.Orbits\n  config: {\n    mass: {\n      g: number\n      orbiter: number\n      attractor: number\n    }\n    distance: {\n      min: number\n      max: number\n    }\n  }\n}\n\nexport const orbits: Behavior<OrbitsSpec> = (\n  particles,\n  _neighborhood,\n  config,\n) => {\n  // Attract each particle to the center\n  const minDistSq = config.distance.min * config.distance.min\n  const maxDistSq = config.distance.max * config.distance.max\n  const mass = config.mass\n  each(particles, particle => {\n    let force = multiply(particle.position, -1) // vector to center\n    const distanceSq = clamp(getMagnitudeSq(force), minDistSq, maxDistSq)\n    const strength = (mass.g * mass.attractor * mass.orbiter) / distanceSq\n    force = setMagnitude(force, strength)\n    force = divide(force, config.mass.orbiter)\n    particle.acceleration = add(particle.acceleration, force)\n  })\n}\n","import { Neighborhood } from '../../particle/neighbors'\nimport { Particle } from '../../particle/particle'\nimport { orbits, OrbitsSpec } from './orbits'\n\nexport type BehaviorSpecs = OrbitsSpec\n\nexport type Behavior<Spec extends BehaviorSpecs> = (\n  particles: Particle[],\n  neighborhood: Neighborhood,\n  config: Spec['config'],\n) => void\n\nexport enum BehaviorNames {\n  Orbits = 'orbits',\n}\n\nconst behaviors: { [name in BehaviorNames]: Behavior<BehaviorSpecs> } = {\n  orbits,\n}\n\nexport const behavior = (\n  particles: Particle[],\n  neighborhood: Neighborhood,\n  spec: BehaviorSpecs,\n) => behaviors[spec.name](particles, neighborhood, spec.config)\n","import { getMagnitudeSq, multiply } from '../../particle/vector-n'\nimport { each, reduce } from '../../util'\nimport { Bounding } from './bounding'\n\nexport const centerScaling: Bounding = (particles, radius) => {\n  if (particles.length < 1) return\n\n  // Avoid Math.sqrt\n  const radiusSq = radius * radius\n\n  // Find longest distance between individual particle & origin\n  const largestMagnitudeSq = reduce(\n    particles,\n    (memo: number, p) => Math.max(memo, getMagnitudeSq(p.position)),\n    0,\n  )\n\n  // Abort if already within limits\n  if (largestMagnitudeSq <= radiusSq) return\n\n  // Scale down all particle positions\n  const factor = radiusSq / largestMagnitudeSq\n  each(particles, p => (p.position = multiply(p.position, factor)))\n}\n","import { Particle } from '../../particle/particle'\nimport { centerScaling } from './centerScaling'\n\nexport type Bounding = (particles: Particle[], radius: number) => void\n\nexport enum BoundingNames {\n  CenterScaling = 'centerScaling',\n}\n\nconst boundings: { [name in BoundingNames]: Bounding } = {\n  centerScaling,\n}\n\nexport const bounding = (\n  particles: Particle[],\n  radius: number,\n  name: BoundingNames,\n) => boundings[name](particles, radius)\n","import { getNeighborhood, Neighborhood } from '../particle/neighbors'\nimport { Particle } from '../particle/particle'\nimport { Particle3 } from '../particle/particle-3'\nimport { add, limitMagnitude, multiply } from '../particle/vector-n'\nimport { each } from '../util'\nimport { behavior, BehaviorNames, BehaviorSpecs } from './behavior/behavior'\nimport { bounding, BoundingNames } from './bounding/bounding'\n\nexport interface SimulationConfig {\n  behaviorSpec: BehaviorSpecs\n  boundingName: BoundingNames\n  maxForce: number\n  maxSpeed: number\n  radius: number\n}\n\nexport interface SimulationData {\n  particles: Particle[]\n  neighborhood: Neighborhood\n}\n\nexport interface SimulationData3 {\n  particles: Particle3[]\n  neighborhood: Neighborhood\n}\n\nconst DEFAULT_CONFIG: SimulationConfig = {\n  behaviorSpec: {\n    name: BehaviorNames.Orbits,\n    config: {\n      mass: {\n        g: 1,\n        orbiter: 10,\n        attractor: 30,\n      },\n      distance: {\n        min: 50,\n        max: 250,\n      },\n    },\n  },\n  boundingName: BoundingNames.CenterScaling,\n  maxForce: 1,\n  maxSpeed: 1,\n  radius: 1,\n}\n\nexport class Simulation {\n  private particles: Particle[] = []\n  private neighborhood: Neighborhood = []\n  private config: SimulationConfig = DEFAULT_CONFIG\n\n  public init(\n    particles: Particle[],\n    neighborhood: Neighborhood,\n    config: Partial<SimulationConfig> = {},\n  ) {\n    this.particles = particles\n    this.neighborhood = neighborhood\n    this.config = { ...this.config, ...config }\n  }\n\n  public tick() {\n    const { particles, neighborhood, config } = this\n\n    // Reset accelerations\n    each(particles, p => (p.acceleration = multiply(p.acceleration, 0)))\n\n    // Apply particle behavior\n    behavior(particles, neighborhood, config.behaviorSpec)\n\n    // Update positions\n    each(particles, p => {\n      p.velocity = add(p.velocity, p.acceleration)\n      p.velocity = limitMagnitude(p.velocity, config.maxSpeed)\n      p.position = add(p.position, p.velocity)\n    })\n\n    // Apply particle bounding\n    bounding(particles, config.radius, config.boundingName)\n\n    // Re-calculate Particle relations\n    this.neighborhood = getNeighborhood(particles)\n  }\n\n  public getData(): SimulationData {\n    return {\n      particles: this.particles,\n      neighborhood: this.neighborhood,\n    }\n  }\n}\n","import { getNeighborhood } from '../particle/neighbors'\nimport { toParticle } from '../particle/particle-msg'\nimport { assertNever, map } from '../util'\nimport { MsgFromWorker, MsgToWorker } from './messages'\nimport { Simulation } from './Simulation'\n\n/**\n * TypeScript currently does not support loading both \"DOM\" and \"WebWorker\"\n * type definitions (in the tsconfig \"lib\" field), so we are falling back to\n * incomplete types hacked out of the desired definitions file\n *\n * Issue:\n * https://github.com/Microsoft/TypeScript/issues/20595\n *\n * Hack:\n * node_modules/typescript/lib/lib.webworker.d.ts -> typings/custom.d.ts\n *\n * Actual:\n * https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope\n *\n */\nconst context = (self as any) as DedicatedWorkerGlobalScope\n\nconst simulation = new Simulation()\n\nconst send = (msg: MsgFromWorker) => context.postMessage(JSON.stringify(msg))\n\ncontext.addEventListener('message', (e: MessageEvent) => {\n  const message = JSON.parse(e.data) as MsgToWorker\n  switch (message.type) {\n    case 'init': {\n      const particles = map(message.particles, toParticle)\n      const neighborhood = getNeighborhood(particles)\n      simulation.init(particles, neighborhood, message.config)\n      break\n    }\n\n    case 'tick': {\n      simulation.tick()\n      send(simulation.getData())\n      break\n    }\n\n    case 'destroy': {\n      context.close()\n      break\n    }\n\n    default: {\n      assertNever(message)\n    }\n  }\n})\n"]}